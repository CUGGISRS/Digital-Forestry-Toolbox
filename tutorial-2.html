<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="UTF-8">
        <title>DFT - Tutorial 2</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="shortcut icon" type="image/png" href="img/favicon_dft.png"/>
        <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
        <link href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css' rel='stylesheet' type='text/css'>

        <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
        <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">

        <script type="text/javascript" async
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>

    </head>
    <body>

        <section class="page-header tutorial">
            <h1 class="project-name">Digital-Forestry-Toolbox</h1>
            <br>
            <!--<h2 class="project-tagline white">A collection of digital forestry tools for Matlab</h2>-->
            <a href="index.html" class="btn"><i class="fa fa-home" aria-hidden="true"></i> Back to homepage</a>
        </section>

        <section class="main-content">

            <h1>Individual tree crown detection using marker controlled watershed segmentation</h1>


            <br>
            <hr>
            <p style="text-align: center"><i class="fa fa-info-circle fa-2x" aria-hidden="true"></i></p>
            <p style="text-align: center"><b>Last update: April 20, 2018 / Matlab r2017b, GNU Octave 4.2.2</b></p>
            <p> In this tutorial, you will learn how to detect individual tree crowns from a raster Canopy Height Model (CHM) using marker controlled watershed segmentation. Before starting, you should:</p>

            <ol>
                <li>Download and uncompress the Digital Forestry Toolbox (DFT) <a href="https://github.com/mparkan/Digital-Forestry-Toolbox/zipball/master">Zip</a> or <a href="https://github.com/mparkan/Digital-Forestry-Toolbox/tarball/master">Tar</a> archive</li>
                <li>Download the <a href="http://maps.zh.ch/download/hoehen/2014/lidar/26995_12710.laz">26995_12710.laz file</a> from the ZÃ¼rich 2014 airborne laser scanning campaign archive and uncompress it with <a href="http://www.laszip.org/">LASzip</a></li>
                <li>Start Matlab/Octave</li>
                <li>Add the DFT folders to the Matlab/Octave search path using <code>addpath(genpath('path to DFT main folder'))</code></li>
                <li>Open <code>dft_tutorial_2.m</code> (located in the tutorials folder)</li>
            </ol>

            <hr>
            <br>

            <h2>
                <a id="step-1" class="anchor" href="step-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><b>Step 1</b> - Reading the LAS file
            </h2>

            <p>We start by reading the LAS file using <code>LASread()</code>:</p>

            <pre><code>pc = LASread('26995_12710.las');</code></pre>

            <p>Note that the point classification uses the following scheme:</p>

            <table>
                <thead>
                    <tr>
                        <th>Class</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>2</td>
                        <td>Terrain</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>Low vegetation (< 50 cm)</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>Medium vegetation (< 3 m)</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>High vegetation (> 3 m)</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>Buildings</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>Outliers and incorrect measurements (Noise)</td>
                    </tr>
                    <tr>
                        <td>10</td>
                        <td>Bridges (> 3m)</td>
                    </tr>
                    <tr>
                        <td>12</td>
                        <td>Strip border points (Overlap)</td>
                    </tr>
                    <tr>
                        <td>15</td>
                        <td>Overhead lines, masts, antennae</td>
                    </tr>
                    <tr>
                        <td>17</td>
                        <td>Other (vehicles, etc. )</td>
                    </tr>
                </tbody>
            </table>


            <h2>
                <a id="step-2" class="anchor" href="step-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><b>Step 2</b> - Computing a raster Canopy Height Model (CHM)
            </h2>

            <p>We now build 0.8 m resolution raster elevation models from the classified 3D point cloud using <code>elevationModels()</code>:</p>


            <pre><code>cellSize = 0.8;
[models, refmat] = elevationModels([pc.record.x, pc.record.y, pc.record.z], ...
    pc.record.classification, ...
    'classTerrain', [2], ...
    'classSurface', [4,5], ...
    'cellSize', cellSize, ...
    'closing', inf, ...
    'smoothingFilter', fspecial('gaussian', [3, 3], 0.8), ...
    'outputModels', {'terrain', 'surface', 'height'}, ...
    'fig', true, ...
    'verbose', true);</code></pre>

            <p>Note that we have only used classes 4 (medium vegetation) and 5 (high vegetation) when computing the surface model (with the <code>'classSurface'</code> parameter). We've also applied a 4x4 pixel Gaussian lowpass filter (with the <code>'smoothingFilter'</code> parameter). The resulting CHM should look like this:</p>

            <figure>
                <img src="img/dft_tutorial_2_ima_1.png" alt="" style="width:90%;">
                <figcaption>Figure 1 - Raster canopy height model.</figcaption>
            </figure>


            <h2>
                <a id="step-3" class="anchor" href="step-3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><b>Step 3</b> - Tree top detection
            </h2>


            <p>In this step, tree top (local maxima) detection is applied to the CHM using a variable radius convolution window defined by a function of the pixel height value:</p>

            $$\DeclareMathOperator*{\max}{max}
            r(h) = 0.5 + 0.25 \cdot ln(\max_h(h,1)) $$

            <p>This function is specified with the <code>'allometry'</code> parameter in <code>canopyPeaks()</code>:</p>

            <pre><code>[peaks_crh, ~] = canopyPeaks(models.height.values, ...
    refmat, ...
    'method', 'allometricRadius', ...
    'allometry', @(h) 0.5 + 0.25*log(max(h,1)), ...
    'fig', true, ...
    'verbose', true);</code></pre>

            The resulting tree top detection should look like this:</p>

        <figure>
            <img src="img/dft_tutorial_2_ima_2.png" alt="" style="width:90%;">
            <figcaption>Figure 2 - Tree top detection.</figcaption>
        </figure>


        <h2>
            <a id="step-4" class="anchor" href="step-4" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><b>Step 4</b> - Marker controlled watershed segmentation
        </h2>

        <p>Using the previously computed CHM, tree top coordinates and boolean mask, we now compute the marker controlled watershed segmentation with <code>treeWatershed()</code>:</p>

        <pre><code>[label_2d, colors] = treeWatershed(models.height.values, ...
    'markers', peaks_crh, ...
    'minHeight', 1, ...
    'removeBorder', true, ...
    'fig', true, ...
    'verbose', true);</code></pre>

        <p>Note that the "removeBorder" argument is set to true, to remove segments that touch the border of the image.</p>

        <p>The resulting label matrix should look like this:</p>


        <figure>
            <img src="img/dft_tutorial_2_ima_3.png" alt="" style="width:90%;">
            <figcaption>Figure 3 - Marker controlled watershed segmentation 2D labels. Note that the segments located on the edge of the CHM have been excluded due to the boolean mask we specified.</figcaption>
        </figure>


        <h2>
            <a id="step-5" class="anchor" href="step-5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><b>Step 5</b> - Computing segment metrics from the label matrix
        </h2>

        <p>From the labelled matrix, it is possible to compute a set of basic features (note that some of the features used below are currently only available in Matlab):</p>

        <pre><code>metrics_2d = regionprops(label_2d, models.height.values, ...
    'Area', 'ConvexArea', 'Eccentricity', ...
    'Perimeter', 'Solidity', 'MinIntensity', ...
    'MeanIntensity', 'MaxIntensity');</code></pre>


        <h2>
            <a id="step-6" class="anchor" href="step-6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><b>Step 6</b> - Transferring 2D labels to the 3D point cloud
        </h2>

        <p>The next step is transferring the 2D labels and colors to the 3D point cloud:</p>

        <pre><code>idxn_color = accumarray(label_2d(:)+1, colors(:), [], @(x) mode(x), nan);
idxl_veg = ismember(pc.record.classification, [4,5]);

% convert map coordinates (x,y) to image coordinates (column, row)
RC = [pc.record.x - refmat(3,1), pc.record.y - refmat(3,2)] / refmat(1:2,:);
RC(:,1) = round(RC(:,1)); % row
RC(:,2) = round(RC(:,2)); % column

ind = sub2ind(size(label_2d), RC(:,1), RC(:,2));

% transfer the label
label_3d = label_2d(ind);
label_3d(~idxl_veg) = 0;
[label_3d(label_3d ~= 0), ~] = grp2idx(label_3d(label_3d ~= 0));

% transfer the color index
color_3d = idxn_color(label_3d + 1);</code></pre>

        <h2>
            <a id="step-7" class="anchor" href="step-7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><b>Step 7</b> - Plotting the colored points cloud
        </h2>

        <p>To plot the colored point cloud, use:</p>

        <pre><code>% define a colormap
cmap = [0,0,0;
    166,206,227;
    31,120,180;
    178,223,138;
    51,160,44;
    251,154,153;
    227,26,28;
    253,191,111;
    255,127,0;
    202,178,214;
    106,61,154;
    255,255,153;
    177,89,40] ./ 255;

figure('Color', [1,1,1])
scatter3(pc.record.x(idxl_veg), ...
    pc.record.y(idxl_veg), ...
    pc.record.z(idxl_veg), ...
    6, ...
    color_3d(idxl_veg), ...
    'Marker', '.')
axis equal tight
colormap(cmap)
xlabel('x')
ylabel('y')
zlabel('z')</code></pre>

        <p>The result should look like this:</p>


        <figure>
            <img src="img/dft_tutorial_2_ima_4.png" alt="" style="width:90%;">
            <figcaption>Figure 4 - Marker controlled watershed segmentation 3D labels. Note that the segments located on the edge of the CHM have been excluded due to the boolean mask.</figcaption>
        </figure>


        <p> You can also plot any individual segment. For example segment nÂ° 42:</p>

        <pre><code>idxl_sample = (label_3d == 42);

figure
scatter3(pc.record.x(idxl_sample), ...
    pc.record.y(idxl_sample), ...
    pc.record.z(idxl_sample), ...
    12, ...
    pc.record.intensity(idxl_sample), ...
    'Marker', '.');
colorbar
axis equal tight
title('Return intensity')
xlabel('x')
ylabel('y')
ylabel('z')</code></pre>

        <figure>
            <img src="img/dft_tutorial_2_ima_5.png" alt="" style="width:90%;">
            <figcaption>Figure 5 - 3D segment nÂ°42 colored by return intensity.</figcaption>
        </figure>


        <h2>
            <a id="step-8" class="anchor" href="step-8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><b>Step 8</b> - Computing segment metrics from the labelled point cloud
        </h2>

        <p>We now compute descriptive metrics directly from the point cloud for each segment using <code>treeMetrics()</code>:</p>

            <pre><code>metrics_3d = treeMetrics(label_3d, ...
    [pc.record.x, pc.record.y, pc.record.z], ...
    pc.record.classification, ...
    pc.record.intensity, ...
    pc.record.return_number, ...
    pc.record.number_of_returns, ...
    nan(length(pc.record.x), 3), ...
    'metrics', {'all'}, ...
    'intensityScaling', true, ...
    'dependencies', false, ...
    'scalarOnly', true, ...
    'verbose', true);
</code></pre>

        <h2>
            <a id="step-9" class="anchor" href="step-9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><b>Step 9</b> - Exporting the segment metrics to CSV and SHP files
        </h2>

        <p>The following illustrates how to export a subset of the segmentation metrics to a Comma Separated Values text file (.csv). You first have to convert the <code>metrics_3d</code> structure to a cell array:</p>

        <pre><code>fields = fieldnames(metrics_3d);
m = length(fields);
n = length(metrics_3d.(fields{1}));

% determine print format
idxl_num = structfun(@(x) isnumeric(x), metrics_3d);
fmt = repmat({'%s'}, [1 m]);
fmt(idxl_num) = {'%.3f'};
fmt = [strjoin(fmt, ','), '\n'];

% convert structure to cell array
C = cell(m, n);
for j = 1:m

    if isnumeric(metrics_3d.(fields{j}))

        C(j,:) = num2cell(metrics_3d.(fields{j}));

    else

        C(j,:) = metrics_3d.(fields{j});

    end

end</code></pre>

        <p>You can then write the data to a CSV file with:</p>

                <pre><code>% write cell array to CSV file
% IMPORTANT: adjust the path to the output CSV file
fid = fopen('26995_12710_seg_metrics.csv', 'w+'); % open file
fprintf(fid, '%s\n', strjoin(fields, ',')); % write header line
fprintf(fid, fmt, C{:}); % write metrics
fclose(fid); % close file</code></pre>

<p>After exporting the CSV file, you can try opening it in any text editor (e.g. <a href="https://notepad-plus-plus.org/">Notepad++</a>).</p>

<p>To export the segmentation metrics to an ESRI shapefile you first have to convert the cell array <code>C</code> to a non-scalar structure and add a "Geometry" field:</p>

<pre><code>% create a non-scalar structure
S = cell2struct(C, fields);
clear C

% add geometry field
[S.Geometry] = deal('Point');</code></pre>

<p>Then use <code>shapewrite()</code> to write the file:</p>

<pre><code>% write non-scalar structure to SHP file
% IMPORTANT: adjust the path to the output SHP file
shapewrite(S, '26995_12710_seg_metrics.shp');</code></pre>


        <p>After exporting the SHP file, you can try opening it in any GIS software (e.g. <a href="http://www.qgis.org">Quantum GIS</a>).</p>

        <h2>
            <a id="step-10" class="anchor" href="step-10" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><b>Step 10</b> - Exporting the labelled and colored point cloud to a LAS 1.4 file
        </h2>


        <p>Finally, we export the colored point cloud to a LAS 1.4 file with <code>LASwrite()</code>. We start by duplicating the source file and adding the RGB records:</p>


<pre><code>% duplicate the source file
r = pc;

% rescale the RGB colors to 16 bit range and add them to the point record
rgb = uint16(cmap(color_3d+1,:) * 65535);
r.record.red = rgb(:,1);
r.record.green = rgb(:,2);
r.record.blue = rgb(:,3);</code></pre>

     <p>We then add the "label" as an extra 32 bit record and add the metadata for this field in the Variable Length Records (cf. <a href="https://www.asprs.org/a/society/committees/standards/LAS_1_4_r13.pdf">ASPRS LAS 1.4 specification</a> for details about the meaning of the metadata fields):</p>

    <pre><code>% add the "label" field to the point record (as an uint32 field)
r.record.label = uint32(label_3d);

% add the "label" uint32 field metadata in the variable length records
% check the ASPRS LAS 1.4 specification for details about the meaning of the fields
% https://www.asprs.org/a/society/committees/standards/LAS_1_4_r13.pdf
vlr = struct;
vlr.value.reserved = 0;
vlr.value.data_type = 5;
vlr.value.options.no_data_bit = 0;
vlr.value.options.min_bit = 0;
vlr.value.options.max_bit = 0;
vlr.value.options.scale_bit = 0;
vlr.value.options.offset_bit = 0;
vlr.value.name = 'label';
vlr.value.unused = 0;
vlr.value.no_data = [0; 0; 0];
vlr.value.min = [0; 0; 0];
vlr.value.max = [0; 0; 0];
vlr.value.scale = [0; 0; 0];
vlr.value.offset = [0; 0; 0];
vlr.value.description = 'LABEL';

vlr.reserved = 43707;
vlr.user_id = 'LASF_Spec';
vlr.record_id = 4;
vlr.record_length_after_header = length(vlr.value) * 192;
vlr.description = 'Extra bytes';

% append the new VLR to the existing VLR
r.variable_length_records(length(r.variable_length_records)+1) = vlr;</code></pre>

     <p>We also adjust the point data record format in the LAS header to support the RGB fields:</p>

     <pre><code>% if necessary, adapt the output record format to add the RGB channel
switch pc.header.point_data_format_id

    case 1 % 1 -> 3

        recordFormat = 3;

    case 4 % 4 -> 5

        recordFormat = 5;

    case 6 % 6 -> 7

        recordFormat = 7;

    case 9 % 9 -> 10

        recordFormat = 10;

    otherwise % 2,3,5,7,8,10

        recordFormat = pc.header.point_data_format_id;

end</code></pre>

<p>Finally, we write the LAS file with <code>LASwrite()</code> and check that it has been correctly written with <code>LASread()</code>:</p>
<pre><code>% write the LAS 1.4 file
% IMPORTANT: adjust the path to the output LAS file
LASwrite(r, ...
    '26995_12710_ws_seg.las', ...
    'version', 14, ...
    'guid', lower(strcat(dec2hex(randi(16,32,1)-1)')), ...
    'systemID', 'SEGMENTATION', ...
    'recordFormat', recordFormat, ...
    'verbose', true);

% you can optionally read the exported file and check it has the
% RGB color and label records
% IMPORTANT: adjust the path to the input LAS file
r2 = LASread('26995_12710_ws_seg.las');</code></pre>

     <p>After exporting, you can try opening the LAS file in any appropriate CAD, GIS or 3D visualization software (e.g. <a href="http://c42f.github.io/displaz/">Displaz</a>, <a href="http://www.danielgm.net/cc/">CloudCompare</a>, <a href="https://www.fugro.com/about-fugro/our-expertise/technology/fugroviewer">FugroViewer</a>).</p>


        <footer class="site-footer">
            <span class="site-footer-owner"><a href="https://github.com/mparkan/Digital-Forestry-Toolbox">Digital-forestry-toolbox</a> is maintained by <a href="https://github.com/mparkan">mparkan</a>.</span>

        </footer>

        </section>


    </body>
</html>
